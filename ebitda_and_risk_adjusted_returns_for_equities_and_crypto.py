# -*- coding: utf-8 -*-
"""EBITDA and Risk-Adjusted Returns for Equities and Crypto

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pXe1GysJ-LcckrkTGFwao9ycnVZ9YwaB
"""

import yfinance as yf
import numpy as np
import matplotlib.pyplot as plt

def get_ebitda(ticker):
    try:
        # Fetch company data
        stock = yf.Ticker(ticker)

        # Annual EBITDA
        annual_financials = stock.financials
        if 'EBITDA' in annual_financials.index:
            annual_ebitda = annual_financials.loc['EBITDA']
            print(f"\nAnnual EBITDA for {ticker} (in USD):")
            for year, ebitda in annual_ebitda.items():
                status = "Negative" if ebitda < 0 else "Positive"
                print(f"  {year}: {ebitda:,.2f} ({status})")
        else:
            print(f"\nAnnual EBITDA data is not available for {ticker}.")

        # Quarterly EBITDA
        quarterly_financials = stock.quarterly_financials
        if 'EBITDA' in quarterly_financials.index:
            quarterly_ebitda = quarterly_financials.loc['EBITDA']
            print(f"\nQuarterly EBITDA for {ticker} (in USD):")
            for quarter, ebitda in quarterly_ebitda.items():
                status = "Negative" if ebitda < 0 else "Positive"
                print(f"  {quarter}: {ebitda:,.2f} ({status})")
        else:
            print(f"\nQuarterly EBITDA data is not available for {ticker}.")
    except Exception as e:
        print(f"An error occurred while fetching EBITDA: {e}")

def calculate_sortino_ratio(ticker, risk_free_rate=0.02):
    try:
        # Fetch historical price data
        stock = yf.Ticker(ticker)
        hist = stock.history(period="1y")  # Last 1 year of data

        if hist.empty:
            print(f"No historical data available for {ticker}.")
            return np.nan

        # Calculate daily returns
        daily_returns = hist['Close'].pct_change().dropna()

        # Calculate average return
        avg_return = daily_returns.mean()

        # Downside deviation: consider only negative returns
        downside_returns = daily_returns[daily_returns < 0]
        downside_deviation = np.sqrt((downside_returns**2).mean())

        # Calculate Sortino Ratio
        sortino_ratio = (avg_return - risk_free_rate / 252) / downside_deviation if downside_deviation > 0 else np.nan

        return sortino_ratio
    except Exception as e:
        print(f"An error occurred while calculating the Sortino Ratio for {ticker}: {e}")
        return np.nan

def visualize_sortino_ratios(tickers, risk_free_rate=0.02):
    ratios = []

    for ticker in tickers:
        print(f"\nCalculating Sortino Ratio for {ticker}...")
        sortino_ratio = calculate_sortino_ratio(ticker, risk_free_rate)
        print(f"Sortino Ratio for {ticker}: {sortino_ratio:.4f}" if not np.isnan(sortino_ratio) else f"Sortino Ratio for {ticker}: Data unavailable.")
        ratios.append(sortino_ratio)

    # Visualization using Matplotlib
    plt.figure(figsize=(10, 6))
    x_pos = np.arange(len(tickers))
    plt.bar(x_pos, ratios, color='skyblue', edgecolor='black')
    plt.xticks(x_pos, tickers)
    plt.xlabel("Ticker Symbols")
    plt.ylabel("Sortino Ratio")
    plt.title("Sortino Ratio Comparison Across Companies")
    plt.axhline(0, color='red', linestyle='--', linewidth=0.8, label='Baseline')
    plt.legend()
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    # User inputs the stock tickers
    tickers = input("Enter the ticker symbols of the companies (comma-separated): ").upper().split(',')
    tickers = [ticker.strip() for ticker in tickers]

    for ticker in tickers:
        get_ebitda(ticker)

    visualize_sortino_ratios(tickers)

symbol = ["BTC-USD","ETH-USD","USDT-USD","BNB-USD","XRP-USD","DOGE-USD","ADA-USD","SOL-USD","DOT-USD","SHIB-USD","MATIC-USD","TRX-USD","LTC-USD"]
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
!pip install mplfinance

# Define the cryptocurrency symbols and the date range
ticker=["BTC-USD","ETH-USD","USDT-USD","BNB-USD","XRP-USD","DOGE-USD","ADA-USD","SOL-USD","DOT-USD","SHIB-USD","MATIC-USD","TRX-USD","LTC-USD"]
start_date = '2019-01-01'
end_date = '2024-12-06'

# Retrieve the historical price data for the specified cryptocurrency symbols
data = yf.download(ticker, start=start_date, end=end_date)
# Extract the closing prices of the cryptocurrencies
df =data["Close"]

# Handling zero or negative values
df = df.replace(0, np.nan)  # Replace zeros with NaN

Log_Returns= np.log(df.div(df.shift()))# Calculate Log-Returns
Log_Returns.dropna(inplace=True)

# Calculate the annualized average log return
ann_returns = Log_Returns.mean() * 365.25
# Calculate the annualized standard deviation of log returns
ann_std =  Log_Returns.std() * np.sqrt(365.25)

# For the sake of simplicity in this tutorial, rf is set to 0
rf =0

# Creating Summary DataFrame
summary = pd.DataFrame(data={"A. Returns":ann_returns,"A. Risk":ann_std })
# Calculating and Adding Sharpe Ratio
summary["Sharpe Ratio"] = (ann_returns -rf) / ann_std
summary.sort_values(by ="Sharpe Ratio", ascending=False) #Sorting the DataFrame by Sharpe Ratio

# Create a scatter plot to visualize the risk-return profile of different cryptocurrencies
summary.plot(kind="scatter", x="A. Risk", y="A. Returns", figsize=(18,12))

# Annotate each point on the scatter plot with the cryptocurrency ticker symbol
for i in summary.index:
    plt.annotate(i,xy=(summary.loc[i,"A. Risk"]+0.002,summary.loc[i,"A. Returns"]+0.006 ), size =15)

plt.title("Cryptocurrency Risk-Return Profile and Sharpe Ratio Comparison", fontsize=18)
plt.xlabel("Annualized Risk (Standard Deviation of Log Returns)", fontsize=14)
plt.ylabel("Annualized Average Log Returns", fontsize=14)

import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Define the cryptocurrency symbols and the date range
ticker=["BTC-USD","ETH-USD","USDT-USD","BNB-USD","XRP-USD","DOGE-USD","ADA-USD","SOL-USD","DOT-USD","SHIB-USD","MATIC-USD","TRX-USD","LTC-USD"]
start_date = '2019-01-01'
end_date = '2024-12-06'

# Retrieve the historical price data for the specified cryptocurrency symbols
data = yf.download(ticker, start=start_date, end=end_date)
# Extract the closing prices of the cryptocurrencies
df =data["Close"]

# Handling zero or negative values
df = df.replace(0, np.nan)  # Replace zeros with NaN

Log_Returns= np.log(df.div(df.shift()))# Calculate Log-Returns
Log_Returns.dropna(inplace=True)

# Calculate the annualized average log return
ann_returns = Log_Returns.mean() * 365.25
# Calculate the annualized standard deviation of log returns
ann_std =  Log_Returns.std() * np.sqrt(365.25)

# Select the Log Returns values that are below zero (negative returns)
downside = Log_Returns[Log_Returns<0]
# Calculate the annualized standard deviation of downside returns
downside_ann_std =  downside.std() * np.sqrt(365.25)

# For the sake of simplicity in this tutorial, rf is set to 0
rf =0

# Creating Summary DataFrame
summary = pd.DataFrame(data={"A. Returns":ann_returns,"A. Risk":ann_std })
# Calculating and Adding Sortino Ratio
summary["Sortino Ratio"] = (ann_returns -rf) / downside_ann_std
summary.sort_values(by ="Sortino Ratio", ascending=False) #Sorting the DataFrame by Sortino Ratio

def ss_ratio (ticker, start_date, end_date):
    import yfinance as yf
    import mplfinance as mpf
    import pandas as pd
    import matplotlib.pyplot as plt
    import seaborn as sns
    import numpy as np


    # Retrieve the historical price data for the specified cryptocurrency symbols
    data = yf.download(ticker, start=start_date, end=end_date)
    df =data["Close"]

    # Handling zero or negative values
    df = df.replace(0, np.nan)  # Replace zeros with NaN

    Log_Returns= np.log(df.div(df.shift()))# Calculate Log-Returns
    Log_Returns.dropna(inplace=True)

    # Calculate the annualized average log return
    ann_returns = Log_Returns.mean() * 365.25
    # Calculate the annualized standard deviation of log returns
    ann_std =  Log_Returns.std() * np.sqrt(365.25)

    # Select the Log Returns values that are below zero (negative returns)
    downside = Log_Returns[Log_Returns<0]
    # Calculate the annualized standard deviation of downside returns
    downside_ann_std =  downside.std() * np.sqrt(365.25)

    # For the sake of simplicity in this tutorial, rf is set to 0
    rf =0

    # Creating Summary DataFrame
    summary = pd.DataFrame(data={"A. Returns":ann_returns,"A. Risk":ann_std }, index=ticker)
    # Calculating and Adding Sortino & Sharpe Ratio
    summary["Sharpe Ratio"] = (ann_returns -rf) / ann_std
    summary["Sortino Ratio"] = (ann_returns -rf) / downside_ann_std
    summary.sort_values(by ="Sortino Ratio", ascending=False) #Sorting the DataFrame by Sortino Ratio
    return summary.sort_values(by ="Sortino Ratio", ascending=False) #Sorting the DataFrame by Sortino Ratio
ss_ratio(["BTC-USD","ETH-USD","USDT-USD","BNB-USD","XRP-USD","DOGE-USD","ADA-USD","SOL-USD","DOT-USD","SHIB-USD","MATIC-USD","TRX-USD","LTC-USD"],'2019-01-01','2024-12-06')